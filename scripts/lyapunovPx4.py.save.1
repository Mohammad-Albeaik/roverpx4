#!/usr/bin/env python

# ROS python API
import rospy
# Joy message structure
# 3D point & Stamped Pose msgs & Orientation as quaternion
from geometry_msgs.msg import Point, PoseStamped, Quaternion, Twist, TwistStamped
#import math for arctan and sqrt function
from math import atan2, sqrt, pi, cos, sin
#import quaternion transformation
from tf.transformations import euler_from_quaternion
from numpy import array
from std_msgs.msg import String

from mavros_msgs.msg import OverrideRCIn


x         			= 0.0 
y         			= 0.0
z         			= 0.0
local_ang 			= [0.0, 0.0, 0.0, 0.0]
roll      			= 0.0
pitch     			= 0.0 
yaw       			= 0.0
velocity 				= Twist()
RcOver 					= OverrideRCIn()
RcOver.channels = [1500,1500,1500,1500,0,0,0,0]
sum_error_v 		= 0
sum_error_w 		= 0
kv 							= 10				# Path planning - Lyapunov controller
kw 							= 30				# Path planning - Lyapunov controller
kvp 							= 120				# Speed PID controller
kvd 							= 0 				# Speed PID controller
kvi 							= 0 				# Speed PID controller
kwp                      				= 10
kwd							= 0
kwi							= 0
dv_Pre 					= 0
dw_Pre 					= 0
omega 					= 0
vel 						= 0



def posCb(msg):
    global x, y, z, roll, pitch, yaw
    x = msg.pose.position.x
    y = msg.pose.position.y
    z = msg.pose.position.z

    local_ang = [msg.pose.orientation.x, msg.pose.orientation.y, msg.pose.orientation.z, msg.pose.orientation.w]
    roll, pitch, yaw = euler_from_quaternion(local_ang)

def velCb(velo):
    global vx,vy,vz, vel

    vx = velo.twist.linear.x
    vy = velo.twist.linear.y
    vz = velo.twist.linear.z
    vel = sqrt(vx*vx + vy*vy + vz*vz)

def angCb(angu):
    global omega

    omega = angu.twist.angular.z


def UpdateSpeed():
    global kv, kw, v, w , velocity, yaw, x ,y, sum_error_w, sum_error_v, kvp, kvi, kvd,kwp, kwd, kwi, dv_Pre, dw_Pre, omega, vel


    xg = 0
    yg = 0
    dx = xg - x
    dy = yg - y

    rho = sqrt(dx*dx + dy*dy)
    alpha = (atan2(dy,dx)) - yaw
    beta = - alpha - yaw


    v = - kv * (-rho*rho*rho *cos(alpha) + rho*(alpha - beta)*sin(alpha))
    w = kw * alpha

    if v > 0.9:
        v = 0.9
    if v < -0.9:
        v = -0.9
    if w > 2.25:
        w = 2.25
    if w < -2.25:
        w = -2.25



    if rho < 0.05: 		# 5 cm away from the final destination 
        v = 0
        w = 0


    velocity.linear.x = v
    velocity.angular.z = w

#------------------------------------------------------------------------- Debug -------------------------------------------------------------------------

    #print("x",x)
    #print("y",y)
    #print("yaw",yaw)
    #print("actual",actual)
    #print("alpha",alpha)
    #print("v  ",v)
    #print("w  ",w)
    #print("wr  ",wr)
    #print("wl  ",wl)

#------------------------------------------------------------------------- Debug end-------------------------------------------------------------------------
#------------------------------------------------------------------------- PID Start ----------------------------------------------------------------------
    r = 0.13 # radius 13 cm
    L = 0.33 # length between wheels 33 cm


    # from desired linear and angular  velocities
    v = 0.8
    w = 0

    dv = v - vel
    dw = w - omega

    sum_error_v = sum_error_v + dv
    sum_error_w = sum_error_w + dw

    if sum_error_v > 100:
        sum_error_v = 100
    elif sum_error_v < -100:
        sum_error_v = -100
    if sum_error_w > 100:
        sum_error_w = 100
    elif sum_error_w < -100:
        sum_error_w = -100

    error_v = - (kvp * dv + kvd * (dv - dv_Pre) + kvi * sum_error_v) # PWM signal for the right wheel
    error_w = - (kwp * dw + kwd * (dw - dw_Pre) + kwi * sum_error_w)  # PWM signal for the left wheel

#    if error_v > 0 :
#       error_v = error_v + 1580
#    else:
#       error_v = error_v + 1420

    dv_Pre = dv
    dw_Pre = dw
    dv 	   = error_v
    dw     = error_w

    WR =  error_v/r + L/r * error_w
    WL =  2 * error_v/r - WR

    WR = WR + 1500
    WL = WL + 1500

    if WR > 2100:
        WR = 2100
    elif WR < 900:
        WR = 900
    if WL > 2100:
        WL = 2100
    elif WL < 900:
        WL = 900

    RcOver.channels = [1500,WR,1500,WL,0,0,0,0]   # 4th

    print("speed v",vel)
    print("rotation w",omega)
    print("dv error ",dv)
    print("dw error ",dw)
    print("actual w ",omega)
    print("actual v ",vel)
    print("PWM R ",WR)
    print("PWM L ",WL)
    print("-------------------------------------------------")

#------------------------------------------------------------------------- PID end-------------------------------------------------------------------------


# Main function
def main():

    # Initiate node
    rospy.init_node('Roveer_CU', anonymous=True)

    # ROS loop rate, [Hz]
    rate = rospy.Rate(150.0)

    # Subscribe to Rover's local position
    rospy.Subscriber('vrpn_client_node/mmb/pose', PoseStamped, posCb)

    # Subscribe to Rover's local linear velocity
    rospy.Subscriber('mavros/local_position/velocity_local', TwistStamped, velCb)
        # Subscribe to Rover's local angular velocity
    rospy.Subscriber('mavros/local_position/velocity_body', TwistStamped, angCb)

    # Speed publisher
    speed_pub = rospy.Publisher('velocity_cm',Twist, queue_size=1)   # change to velocity_cm

    # RCOveride publisher
    rc_pub = rospy.Publisher('mavros/rc/override',OverrideRCIn, queue_size=1)


    # ROS main loop
    while not rospy.is_shutdown():

            UpdateSpeed()
            speed_pub.publish(velocity)
            rc_pub.publish(RcOver)
            rate.sleep()

    # Stop the rover before killiing the node.
    RcOver.channels = [1500,1500,1500,1500,0,0,0,0]
    rc_pub.publish(RcOver)
    rate.sleep()
    rc_pub.publish(RcOver)

if __name__ == '__main__':
    try:
            main()
    except rospy.ROSInterruptException:
            pass
